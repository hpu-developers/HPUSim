"""
Task Lookaside Buffer ---- to look up for the mapping of speculative tasks in the speculative memory with their actual physical memory address

Stores an entry corresponding to a "speculation_ID". Each such ID corresponds to a set of speculative tasks
Each entry has task_ID, start_address in the speculative memory and size

"""

class TLB:

    def __init__(self, size, base_addr):
        # MAX limit on the size of the buffer
        self.MAX_SIZE = size

        #THe base address of the transactional memory
        self.base = base_addr

        # Current pointer in the memory
        self.curr_ptr = base_addr

        # Total size of speculation buffer. 256 blocks in 64MB memory
        self.TM_SIZE = 256

        # The pointer can not exceed the max size of the Transactional memory
        self.max_ptr = base_addr + self.TM_SIZE

        # Stored mappings
        self.mapping = dict()

        # All the spec_id
        self.mapping_id = dict()

    def add_entry(self, spec_ID, task_ID, mem_start, mem_size):
        """
            This is when a speculative instruction is being executed. It adds a new entry tp the TM and returns the
            mapped address. It needs to know the id for specualtion and task. 

            Inputs: 
                    spec_ID   - speculation_ID of the group of tasks. Generated by dispatch unit
                    task_ID   - individual task ID
                    mem_start - starting address in the physical memory
                    mem_size  - number of blocks in the physical memory
            Returns:
                    (spec_buffer start address, True) if entry added successfully, (None, False) if TLB is full and stall is required
        """
        # Create an entry to be pushed into the buffer
        # A dict keyed by speculation_ID

        # Get the next mapping.
        req_size = int(mem_size, 16)

        mapped_addr = self.curr_ptr
        mapped_addr = hex(mapped_addr)[2:].zfill(4)

        #update the current pointer
        self.curr_ptr += req_size
        assert (self.curr_ptr <= self.max_ptr), "Exceeded the Transactional Memory"

        # Create an entry (would be overwritten if the entry existed before)
        self.mapping[mem_start] = { 'addr' : mapped_addr, 'size' : mem_size, 'task_ID': task_ID}
        # Store all the mappings related to this spec_id (for clearing wrong speculations)
        if(spec_ID not in self.mapping_id.keys()):
            self.mapping_id[spec_ID] = [mem_start]
        else:
            self.mapping_id[spec_ID].append(mem_start)

        # Assuming for now that the TLB will never get full
        # TODO  Need to add overflow condition in mem_track module
        assert (len(self.mapping) <= self.MAX_SIZE), "Overflow in the TLB"

        return mapped_addr

    def delete_entry(self, spec_ID, task_ID = None):
        """
            Delete all tasks corresponding to a spec_ID
            Inputs:
                    spec_ID - which needs to be removed
                    task_ID - (for future use) a particular task to remove
            Returns:
                    True if success, asserts otherwise
        """
        assert (len(self.mapping) > 0), "TLB is empty, can't delete"
        assert (spec_ID in self.mapping_id.keys()), "Seriously!! Is this the spec_ID you wanna delete? Check again because I ain't got this one"
        to_delete = self.mapping_id[spec_ID]

        tasks_to_abort = []
        for mapping in to_delete:
            tasks_to_abort.append(self.mapping[mapping]['task_ID'])
            self.mapping.pop(mapping, None)

        # Return the task IDs to abort
        return tasks_to_abort

    def retrieve_entry(self, mem_start, mem_size):
        """
            Get an entry corresponding to a memory address
            Inputs:
                   mem_start, mem_size 
            Returns:
                   Mapping corresponding to mem_start, mem_size 
                   (spec_mem_start, pm_mem_start, mem_size, valid)
        """
        if(mem_start in self.mapping.keys()):
            return (self.mapping[mem_start]['addr'], 1)
        else:
            return (None, 0)

    def get_all_mappings(self):
        """
            returns a list of all mappings
            each mapping is a dict keyed by spec_Id and with values (task_ID, mem_start, mem_size)
        """
        return self.mapping


if __name__ == "__main__":
     new_mapping = TLB(128, 0)
     new_mapping.add_entry(0,0,'100','50')
     new_mapping.add_entry(0,1,'200','50')
     new_mapping.add_entry(1,2,'500','50')
     print(new_mapping.retrieve_entry('100','0'))
     print(new_mapping.retrieve_entry(0,1))
     print(new_mapping.retrieve_entry('200','2'))
     new_mapping.delete_entry('100')
     print(new_mapping.retrieve_entry('100','2'))
     print(new_mapping.get_all_mappings())
     new_mapping.add_entry(2,10,'1000','100')
     print(new_mapping.get_all_mappings())
     new_mapping.delete_entry('0')

